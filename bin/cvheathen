#!/usr/bin/env ruby
#
# Script:      cvheathen
# Description: This script will walk a directory, looking for files to convert, send them to Heathen
#              and store the results in a second directory, with the same tree structure.
#
# Usage:       cvheathen -i DIR -o DIR {opts}
#
# Options:     -i      directory to read files from
#              -o      directory to write converted file to
#
#
require 'optparse'
require 'pathname'
$: << Pathname.new(__FILE__).realpath.parent.parent
$: << Pathname.new(__FILE__).realpath.parent.parent + 'lib'
require 'autoheathen'

in_dir = nil
out_dir = nil
logger = Logger.new(nil)
language = 'en'

OptionParser.new do |opts|
  opts.on( '-i', '--input-directory DIR', 'Directory to read from' ) { |i| in_dir = i }
  opts.on( '-o', '--output-directory DIR', 'Converted files will be stored in this directory' ) { |d| out_dir = d }
  opts.on( '-v', '--verbose', 'Running commentary' ) { logger = Logger.new(STDOUT) }
  opts.on( '-l', '--language LANGUAGE', 'The language of the input files (currently only "en" and "es" allowed)' ) { |l| language = l }
  opts.on( '-h', '--help', 'This message' ) { puts opts; exit }
end.parse!

abort "Please specify an input directory" unless in_dir
abort "Please specify an output directory" unless out_dir

converter = AutoHeathen::Converter.new( { logger: logger } )

Dir.glob( "#{in_dir}/**/*" ).each do |file|
  next if File.directory? file

  # Construct the output directory
  dir_part = File.dirname( file.gsub "#{in_dir}/", "")
  outdir = Pathname.new(out_dir) + File.dirname(dir_part)
  FileUtils.mkdir_p outdir unless File.exist? outdir

  logger.info "Processing: #{file}"

  begin
    content = File.read(file)
    action = converter.get_action content.content_type
    logger.debug "  content_type: #{content.content_type}, action: #{action}"
    start_time = Time.now
    outfile, data = converter.convert action, language, file, content
    outfile = outdir + File.basename(outfile)
    logger.info " writing file: #{outfile}"
    File.open outfile, "w" do |f|
      f.write data
    end
    logger.debug " completed in %0.2f s"%[Time.now-start_time]
  rescue StandardError => e
    logger.warn "  failed: #{e.message}"
  end
end
